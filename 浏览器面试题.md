## 01. 浏览器的渲染流程

### 简要回答

浏览器渲染流程主要包括以下步骤：

1. 解析 HTML 构建 DOM 树
2. 解析 CSS 构建 CSSOM 树
3. 将 DOM 和 CSSOM 合并成渲染树
4. 布局计算（Layout/Reflow）
5. 绘制（Paint）
6. 合成（Composite）

### 详细解答

1. **构建 DOM 树（Parse HTML）**

   ```html
   <!-- 1. 接收 HTML 文本 -->
   <html>
     <head>
       <link rel="stylesheet" href="style.css" />
       <script src="app.js"></script>
     </head>
     <body>
       <div class="container">
         <h1>标题</h1>
         <p>段落内容</p>
       </div>
     </body>
   </html>

   <!-- 2. 转换为 DOM 树 -->
   <!--
    Document
      ├── html
      │   ├── head
      │   │   ├── link[rel="stylesheet"]
      │   │   └── script
      │   └── body
      │       └── div.container
      │           ├── h1
      │           │   └── "标题"
      │           └── p
      │               └── "段落内容"
    -->
   ```

2. **构建 CSSOM 树（Parse CSS）**

   ```css
   /* 1. CSS 文本 */
   html {
     font-size: 16px;
   }
   body {
     margin: 0;
     font-family: Arial;
   }
   .container {
     width: 100%;
     max-width: 1200px;
     margin: 0 auto;
   }
   h1 {
     font-size: 2em;
     color: #333;
   }

   /* 2. 转换为 CSSOM 树 */
   /*
   CSSOM
     ├── html
     │   └── font-size: 16px
     ├── body
     │   ├── margin: 0
     │   └── font-family: Arial
     ├── .container
     │   ├── width: 100%
     │   ├── max-width: 1200px
     │   └── margin: 0 auto
     └── h1
         ├── font-size: 2em
         └── color: #333
   */
   ```

3. **构建渲染树（Render Tree）**

   ```css
   /* 1. 合并 DOM 和 CSSOM */
   .visible {
     display: block;
     visibility: visible;
     opacity: 1;
   }

   /* 2. 不会出现在渲染树中的元素 */
   .hidden {
     display: none; /* 完全不会出现 */
   }
   .invisible {
     visibility: hidden; /* 占位但不可见 */
   }
   .transparent {
     opacity: 0; /* 完全透明但可交互 */
   }

   /* 3. 渲染树示例 */
   /*
   RenderTree
     ├── RenderBody (body)
     │   └── RenderBlock (div.container)
     │       ├── RenderBlock (h1)
     │       │   └── RenderText ("标题")
     │       └── RenderBlock (p)
     │           └── RenderText ("段落内容")
     */
   ```

4. **布局计算（Layout/Reflow）**

   ```css
   /* 1. 触发布局计算的属性 */
   .trigger-layout {
     /* 位置相关 */
     position: relative;
     top: 10px;
     left: 20px;

     /* 尺寸相关 */
     width: 100px;
     height: 100px;
     padding: 10px;
     margin: 10px;

     /* 文本相关 */
     font-size: 16px;
     line-height: 1.5;
     text-align: center;
   }

   /* 2. 避免重排的属性 */
   .no-layout {
     /* 使用 transform 代替位置改变 */
     transform: translate(10px, 20px);

     /* 使用 opacity 代替显示隐藏 */
     opacity: 0;
   }
   ```

5. **绘制（Paint）**

   ```css
   /* 1. 触发重绘的属性 */
   .trigger-paint {
     /* 颜色相关 */
     color: red;
     background-color: blue;
     border-color: green;

     /* 阴影相关 */
     box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
     text-shadow: 1px 1px 2px black;
   }

   /* 2. 分层绘制 */
   .paint-layer {
     /* 创建新的绘制层 */
     position: fixed;
     transform: translateZ(0);
     will-change: transform;
   }
   ```

6. **合成（Composite）**

   ```css
   /* 1. 创建合成层 */
   .composite-layer {
     /* 硬件加速 */
     transform: translateZ(0);
     backface-visibility: hidden;
     will-change: transform, opacity;
   }

   /* 2. 优化动画性能 */
   .animation {
     /* 使用 transform 和 opacity */
     transform: scale(1.1);
     opacity: 0.8;
     transition: transform 0.3s, opacity 0.3s;
   }
   ```

### 性能优化建议

1. **解析阶段优化**

   ```html
   <!-- 1. HTML 解析优化 -->
   <head>
     <!-- CSS 优先加载 -->
     <link rel="stylesheet" href="critical.css" />

     <!-- JavaScript 延迟加载 -->
     <script defer src="app.js"></script>
     <script async src="analytics.js"></script>

     <!-- 预加载关键资源 -->
     <link rel="preload" href="important.js" as="script" />
     <link rel="preload" href="hero.jpg" as="image" />
   </head>
   ```

2. **渲染阶段优化**

   ```css
   /* 1. 避免重排重绘 */
   .performance {
     /* 使用 transform 代替位置变化 */
     transform: translate(100px, 100px);

     /* 批量修改样式 */
     .batch-update {
       transform: translateX(100px);
       opacity: 0.5;
       color: blue;
     }
   }

   /* 2. 提升合成层 */
   .layer {
     transform: translateZ(0);
     will-change: transform;
     /* 注意：不要滥用 */
   }
   ```

3. **资源加载优化**

   ```html
   <!-- 1. 资源优先级 -->
   <head>
     <!-- DNS 预解析 -->
     <link rel="dns-prefetch" href="//example.com" />

     <!-- 预连接 -->
     <link rel="preconnect" href="https://example.com" />

     <!-- 预加载 -->
     <link rel="preload" href="style.css" as="style" />

     <!-- 预渲染 -->
     <link rel="prerender" href="next-page.html" />
   </head>
   ```

4. **注意事项**

   - 解析阶段

     - CSS 会阻塞渲染和 JavaScript 执行
     - JavaScript 会阻塞 DOM 解析
     - 使用 async/defer 优化脚本加载

   - 构建阶段

     - 降低 DOM 树的复杂度
     - 减少 CSS 选择器的复杂度
     - 避免深层级的嵌套

   - 渲染阶段
     - 避免频繁的重排操作
     - 使用 transform 和 opacity 做动画
     - 合理使用硬件加速
     - 控制合成层的数量

## 02. 重排（回流）和重绘的区别

### 简要回答

重排（Reflow）和重绘（Repaint）是浏览器渲染过程中的两种操作。重排是元素的位置和大小发生改变需要重新计算布局的过程，重绘是元素外观改变但不影响布局的渲染过程。重排必定会触发重绘，而重绘不一定会触发重排。

### 详细解答

1. **触发重排的操作**

   ```css
   /* 1. 元素大小和位置变化 */
   .trigger-reflow {
     /* 几何属性 */
     width: 100px;
     height: 100px;
     padding: 10px;
     margin: 10px;
     border-width: 1px;

     /* 定位属性 */
     position: relative;
     top: 10px;
     left: 10px;
     float: left;

     /* 文字属性 */
     font-size: 14px;
     line-height: 1.5;
     text-align: center;
   }

   /* 2. 页面初始渲染 */
   .initial-render {
     /* DOM 元素添加或删除 */
     display: none; /* 显示隐藏 */
   }

   /* 3. 窗口尺寸变化 */
   @media (min-width: 768px) {
     .responsive {
       width: 750px;
     }
   }
   ```

2. **触发重绘的操作**

   ```css
   /* 1. 外观属性变化 */
   .trigger-repaint {
     /* 颜色相关 */
     color: red;
     background-color: blue;
     border-color: green;
     outline-color: orange;

     /* 可见性 */
     visibility: hidden;

     /* 其他样式 */
     box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
     text-decoration: underline;
   }

   /* 2. 不会触发重排的变化 */
   .only-repaint {
     /* 使用 transform */
     transform: translateX(10px);

     /* 使用 opacity */
     opacity: 0.5;
   }
   ```

### 性能优化建议

1. **避免重排优化**

   ```css
   /* 1. 批量修改样式 */
   .batch-update {
     /* 不推荐 */
     .element {
       width: 100px;
       height: 100px;
       padding: 10px;
       margin: 10px;
     }

     /* 推荐：使用 class 切换 */
     .element.updated {
       width: 100px;
       height: 100px;
       padding: 10px;
       margin: 10px;
     }
   }

   /* 2. 使用 transform 代替位置改变 */
   .position-change {
     /* 不推荐 */
     top: 10px;
     left: 10px;

     /* 推荐 */
     transform: translate(10px, 10px);
   }
   ```

2. **优化实践**

   ```css
   /* 1. 使用 absolute 或 fixed 定位 */
   .optimize-layout {
     /* 脱离文档流，减少重排影响范围 */
     position: absolute;
     top: 0;
     left: 0;
   }

   /* 2. 开启 GPU 加速 */
   .gpu-accelerate {
     /* 创建新的图层 */
     transform: translateZ(0);
     will-change: transform;
   }

   /* 3. 控制重排范围 */
   .contain-layout {
     /* 创建独立的渲染层 */
     contain: layout;
     contain: paint;
   }
   ```

3. **最佳实践**

   - 样式管理

     ```css
     /* 1. 集中修改样式 */
     .style-changes {
       /* 使用 CSS 类统一管理样式变化 */
       &.active {
         transform: scale(1.1);
         opacity: 1;
       }
     }

     /* 2. 避免使用表格布局 */
     .table-layout {
       /* 不推荐使用表格布局 */
       display: table;

       /* 推荐使用弹性布局 */
       display: flex;
     }
     ```

   - 动画优化

     ```css
     /* 使用 transform 和 opacity 实现动画 */
     .animation {
       /* 位置动画 */
       transform: translateX(100px);
       transition: transform 0.3s;

       /* 显示隐藏 */
       opacity: 0;
       transition: opacity 0.3s;
     }
     ```

4. **注意事项**

   - 重排影响

     - 改变窗口大小
     - DOM 元素增删
     - 元素位置变化
     - 元素尺寸变化

   - 重绘影响

     - 颜色变化
     - 背景图变化
     - 可见性变化
     - 阴影效果

   - 性能考虑
     - 避免频繁操作样式
     - 使用类名切换样式
     - 使用 transform 和 opacity
     - 合理使用图层优化

## 03. 为什么 transform 更高效？

### 简要回答

transform 更高效是因为它不会触发重排和重绘，而是直接在 GPU 中完成处理。使用 transform 会创建一个新的图层，该图层可以独立于普通文档流进行处理，由 GPU 直接渲染，从而提高性能。

### 详细解答

1. **图层创建**

   ```css
   /* 1. 创建独立图层 */
   .composite-layer {
     /* transform 会创建新的合成层 */
     transform: translateZ(0);

     /* 其他创建合成层的属性 */
     will-change: transform;
     backface-visibility: hidden;
   }

   /* 2. 对比传统方式 */
   .traditional {
     /* 会触发重排 */
     left: 100px;
     top: 100px;
   }
   ```

2. **GPU 加速**

   ```css
   /* 1. 启用 GPU 加速 */
   .gpu-accelerated {
     /* 3D transform 触发 GPU 加速 */
     transform: translate3d(0, 0, 0);

     /* 2D transform 也会启用 GPU */
     transform: translateX(100px);
     transform: scale(1.2);
     transform: rotate(45deg);
   }

   /* 2. 硬件加速的其他属性 */
   .hardware-accelerated {
     /* 透明度变化也由 GPU 处理 */
     opacity: 0.8;

     /* 过滤器效果 */
     filter: blur(5px);
   }
   ```

### 性能优化建议

1. **合理使用**

   ```css
   /* 1. 动画优化 */
   .animation {
     /* 位置动画使用 transform */
     transform: translateX(100px);
     transition: transform 0.3s;

     /* 不要同时使用多个 transform */
     &.complex {
       /* 不推荐 */
       transform: translateX(100px) scale(1.2) rotate(45deg);
     }
   }

   /* 2. 避免过度使用 */
   .caution {
     /* 不要为所有元素都添加 */
     transform: translateZ(0); /* 谨慎使用 */
   }
   ```

2. **最佳实践**

   ```css
   /* 1. 动画元素独立图层 */
   .animated-element {
     /* 使用 will-change 提前告知浏览器 */
     will-change: transform;

     /* 动画开始时的变换 */
     transform: translateX(0);
     transition: transform 0.3s;

     /* 动画结束状态 */
     &.active {
       transform: translateX(100px);
     }
   }

   /* 2. 合理管理图层 */
   .layer-management {
     /* 动画结束后移除图层 */
     will-change: auto;

     /* 必要时创建图层 */
     &.animating {
       will-change: transform;
     }
   }
   ```

3. **注意事项**

   - 性能考虑

     - 合理控制图层数量
     - 及时回收不需要的图层
     - 避免大量元素同时动画

   - 使用场景

     - 位置移动使用 translate
     - 缩放使用 scale
     - 旋转使用 rotate
     - 透明度变化使用 opacity

   - 优化建议
     - 使用 will-change 提前声明
     - 避免过度使用 3D transform
     - 注意内存占用
     - 控制动画元素大小

4. **对比分析**

   ```css
   /* 1. 传统方式 vs transform */
   .comparison {
     /* 传统方式：触发重排 */
     .traditional {
       position: relative;
       left: 100px;
       top: 50px;
     }

     /* transform：GPU 加速 */
     .optimized {
       transform: translate(100px, 50px);
     }
   }

   /* 2. 性能影响 */
   .performance {
     /* 影响整个文档流 */
     .reflow {
       margin-left: 100px;
     }

     /* 独立图层处理 */
     .transform {
       transform: translateX(100px);
     }
   }
   ```

## 04. 介绍一下资源提示关键词

### 简要回答

资源提示关键词（Resource Hints）是一组 HTML 标签属性，用于指示浏览器提前加载、预连接或预处理某些资源，从而优化页面加载性能。主要包括 preload、prefetch、preconnect、dns-prefetch 和 prerender。

### 详细解答

1. **preload（预加载）**

   ```html
   <!-- 1. 预加载关键资源 -->
   <head>
     <!-- CSS 文件预加载 -->
     <link rel="preload" href="critical.css" as="style" />

     <!-- 字体文件预加载 -->
     <link rel="preload" href="font.woff2" as="font" crossorigin />

     <!-- 图片预加载 -->
     <link rel="preload" href="hero.jpg" as="image" />
   </head>

   <!-- 2. 使用预加载的资源 -->
   <link rel="stylesheet" href="critical.css" />
   <img src="hero.jpg" alt="hero image" />
   ```

2. **prefetch（预获取）**

   ```html
   <!-- 1. 下一页资源预获取 -->
   <head>
     <!-- 下一页 CSS -->
     <link rel="prefetch" href="next-page.css" />

     <!-- 下一页 JavaScript -->
     <link rel="prefetch" href="next-page.js" />

     <!-- 可能需要的图片 -->
     <link rel="prefetch" href="next-page-hero.jpg" />
   </head>

   <!-- 2. 预获取整个页面 -->
   <link rel="prefetch" href="/next-page.html" />
   ```

3. **preconnect（预连接）**

   ```html
   <!-- 1. 预先建立连接 -->
   <head>
     <!-- CDN 预连接 -->
     <link rel="preconnect" href="https://cdn.example.com" />

     <!-- API 服务器预连接 -->
     <link rel="preconnect" href="https://api.example.com" />

     <!-- 跨源资源预连接 -->
     <link rel="preconnect" href="https://fonts.googleapis.com" crossorigin />
   </head>
   ```

### 使用建议

1. **最佳实践**

   ```html
   <!-- 1. 组合使用资源提示 -->
   <head>
     <!-- DNS 预解析 -->
     <link rel="dns-prefetch" href="//example.com" />

     <!-- 随后预连接 -->
     <link rel="preconnect" href="https://example.com" />

     <!-- 最后预加载 -->
     <link rel="preload" href="https://example.com/style.css" as="style" />
   </head>

   <!-- 2. 按优先级使用 -->
   <head>
     <!-- 关键资源优先 -->
     <link rel="preload" href="critical.js" as="script" />

     <!-- 次要资源预获取 -->
     <link rel="prefetch" href="non-critical.js" />
   </head>
   ```

2. **性能优化**

   ```html
   <!-- 1. 优化字体加载 -->
   <head>
     <!-- 字体文件预加载 -->
     <link
       rel="preload"
       href="font.woff2"
       as="font"
       type="font/woff2"
       crossorigin
     />

     <!-- 字体样式 -->
     <style>
       @font-face {
         font-family: 'MyFont';
         src: url('font.woff2') format('woff2');
         font-display: swap;
       }
     </style>
   </head>

   <!-- 2. 优化图片加载 -->
   <head>
     <!-- 首屏图片预加载 -->
     <link rel="preload" href="hero.jpg" as="image" />

     <!-- 其他图片预获取 -->
     <link rel="prefetch" href="gallery.jpg" />
   </head>
   ```

3. **注意事项**

   - 资源优先级

     - preload 用于当前页面关键资源
     - prefetch 用于未来可能需要的资源
     - 避免过度预加载

   - 连接管理

     - preconnect 用于确定要连接的域名
     - dns-prefetch 用于仅需 DNS 解析的域名
     - 控制预连接数量

   - 性能考虑
     - 避免预加载过多资源
     - 注意浏览器支持情况
     - 监控资源加载性能

4. **应用场景**

   ```html
   <!-- 1. 单页应用优化 -->
   <head>
     <!-- 路由预获取 -->
     <link rel="prefetch" href="/about" as="document" />

     <!-- 组件预加载 -->
     <link rel="preload" href="app.js" as="script" />
   </head>

   <!-- 2. 电商网站优化 -->
   <head>
     <!-- 商品图片预加载 -->
     <link rel="preload" href="product.jpg" as="image" />

     <!-- 搜索接口预连接 -->
     <link rel="preconnect" href="https://api.search.com" />
   </head>
   ```

## 05. 介绍一下 async 和 defer

### 简要回答

async 和 defer 都是用于优化 JavaScript 文件加载的脚本属性。它们的主要区别在于:

- async: 异步加载脚本,加载完成后立即执行,不保证执行顺序
- defer: 异步加载脚本,但要等到 HTML 解析完成后才执行,并且按照顺序执行

### 详细解答

1. **正常加载**

```html
<!-- 1. 普通脚本 -->
<head>
  <!-- 会阻塞 HTML 解析 -->
  <script src="app.js"></script>

  <!-- 内联脚本也会阻塞 -->
  <script>
    console.log('阻塞脚本')
  </script>
</head>
```

2. **async 加载**

```html
<!-- 1. async 属性使用 -->
<head>
  <!-- 异步加载,加载完立即执行 -->
  <script async src="analytics.js"></script>
  <script async src="tracker.js"></script>

  <!-- 适合独立的脚本 -->
  <script async src="widget.js"></script>
</head>

<!-- 2. 动态添加的 async 脚本 -->
<script>
  // 动态创建的脚本默认是 async 的
  const script = document.createElement('script')
  script.src = 'dynamic.js'
  document.head.appendChild(script)
</script>
```

3. **defer 加载**

```html
<!-- 1. defer 属性使用 -->
<head>
  <!-- 异步加载,按顺序执行 -->
  <script defer src="lib.js"></script>
  <script defer src="app.js"></script>

  <!-- 依赖其他脚本的场景 -->
  <script defer src="framework.js"></script>
  <script defer src="framework-plugin.js"></script>
</head>
```

### 使用建议

1. **最佳实践**

```html
<!-- 1. 不同场景的选择 -->
<head>
  <!-- 需要操作 DOM 的脚本 -->
  <script defer src="dom-manipulation.js"></script>

  <!-- 独立的统计脚本 -->
  <script async src="analytics.js"></script>

  <!-- 关键脚本提前加载 -->
  <link rel="preload" href="critical.js" as="script" />
  <script defer src="critical.js"></script>
</head>

<!-- 2. 模块脚本 -->
<script type="module" src="app.mjs"></script>
<!-- module 脚本默认具有 defer 的特性 -->
```

2. **性能优化**

```html
<!-- 1. 脚本分组 -->
<head>
  <!-- 核心功能 -->
  <script defer src="core.js"></script>
  <script defer src="app.js"></script>

  <!-- 非核心功能 -->
  <script async src="social-share.js"></script>
  <script async src="ads.js"></script>
</head>

<!-- 2. 内联脚本处理 -->
<script>
  // 初始化数据
  window.__INITIAL_DATA__ = {
    /*...*/
  }
</script>
<script defer src="app.js"></script>
```

3. **注意事项**

- 加载时机

  - async: 下载完成立即执行
  - defer: DOM 解析完成后执行
  - 普通脚本: 会阻塞 DOM 解析

- 执行顺序

  - async: 不保证执行顺序
  - defer: 按照文档中的顺序执行
  - 普通脚本: 按照文档中的顺序执行

- 使用场景
  - async: 独立的第三方脚本
  - defer: 需要操作 DOM 或有依赖关系的脚本
  - 普通脚本: 需要立即执行的关键脚本

4. **应用示例**

```html
<!-- 1. 典型的页面脚本加载 -->
<head>
  <!-- 关键样式 -->
  <link rel="stylesheet" href="critical.css" />

  <!-- 核心脚本 -->
  <script defer src="vendor.js"></script>
  <script defer src="main.js"></script>

  <!-- 分析和监控 -->
  <script async src="analytics.js"></script>
  <script async src="monitoring.js"></script>
</head>

<!-- 2. 条件加载 -->
<script>
  // 根据条件动态加载脚本
  if (condition) {
    const script = document.createElement('script')
    script.src = 'feature.js'
    script.async = true // 或 false，取决于需求
    document.head.appendChild(script)
  }
</script>
```

## 06. 介绍一下浏览器缓存

### 简要回答

浏览器缓存是一种将网页资源（如 HTML、CSS、JavaScript、图片等）存储在本地的机制，减少重复请求，提高页面加载速度和性能。主要分为四类：HTTP 缓存（强缓存和协商缓存）、Memory Cache、Disk Cache 和 Service Worker Cache。

### 详细解答

1. **HTTP 缓存 - 强缓存**

   ```http
   <!-- 1. Expires (HTTP/1.0) -->
   Expires: Wed, 21 Oct 2023 07:28:00 GMT

   <!-- 2. Cache-Control (HTTP/1.1) -->
   Cache-Control: max-age=31536000
   Cache-Control: public, max-age=86400
   Cache-Control: private, max-age=3600
   Cache-Control: no-cache
   Cache-Control: no-store
   Cache-Control: must-revalidate
   Cache-Control: immutable
   ```

2. **HTTP 缓存 - 协商缓存**

   ```http
   <!-- 1. Last-Modified / If-Modified-Since -->
   <!-- 服务器响应头 -->
   Last-Modified: Wed, 21 Oct 2023 07:28:00 GMT

   <!-- 浏览器请求头 -->
   If-Modified-Since: Wed, 21 Oct 2023 07:28:00 GMT

   <!-- 2. ETag / If-None-Match -->
   <!-- 服务器响应头 -->
   ETag: "33a64df551425fcc55e4d42a148795d9f25f89d4"

   <!-- 浏览器请求头 -->
   If-None-Match: "33a64df551425fcc55e4d42a148795d9f25f89d4"
   ```

3. **浏览器内存缓存 (Memory Cache)**

   ```html
   <!-- 1. 内存缓存特点 -->
   <!--
   - 存储在内存中，读取速度快
   - 容量有限，关闭标签页后消失
   - 常用于当前页面的图片、脚本等资源
   -->

   <!-- 2. 内存缓存示例 -->
   <img src="logo.png" />
   <!-- 再次访问同一图片时可能从内存缓存获取 -->
   <img src="logo.png" />
   ```

4. **硬盘缓存 (Disk Cache)**

   ```html
   <!-- 1. 硬盘缓存特点 -->
   <!--
   - 持久化存储，浏览器关闭后依然保留
   - 容量较大，可存储更多资源
   - 读取速度比内存缓存慢
   -->

   <!-- 2. 硬盘缓存使用场景 -->
   <!--
   - 大型文件和不常用资源
   - CSS、JavaScript 等静态资源
   - 符合 HTTP 缓存策略的资源
   -->
   ```

5. **Service Worker 缓存**

   ```javascript
   // 1. 注册 Service Worker
   if ('serviceWorker' in navigator) {
     navigator.serviceWorker
       .register('/sw.js')
       .then((registration) => {
         console.log('SW 注册成功:', registration.scope)
       })
       .catch((error) => {
         console.log('SW 注册失败:', error)
       })
   }

   // 2. Service Worker 缓存实现 (sw.js)
   const CACHE_NAME = 'v1-cache'
   const urlsToCache = [
     '/',
     '/index.html',
     '/styles/main.css',
     '/scripts/main.js',
     '/images/logo.png'
   ]

   // 安装阶段缓存资源
   self.addEventListener('install', (event) => {
     event.waitUntil(
       caches.open(CACHE_NAME).then((cache) => {
         return cache.addAll(urlsToCache)
       })
     )
   })

   // 拦截请求并从缓存响应
   self.addEventListener('fetch', (event) => {
     event.respondWith(
       caches.match(event.request).then((response) => {
         // 缓存命中，返回缓存
         if (response) {
           return response
         }
         // 缓存未命中，发起网络请求
         return fetch(event.request)
       })
     )
   })
   ```

### 使用建议

1. **缓存策略选择**

   ```http
   <!-- 1. 不同资源的缓存策略 -->
   <!-- HTML 文档：协商缓存 -->
   Cache-Control: no-cache

   <!-- CSS/JS 文件：带版本号的强缓存 -->
   Cache-Control: public, max-age=31536000
   <!-- 文件命名: main.v2.css, main.v2.js -->

   <!-- 图片和字体：强缓存 -->
   Cache-Control: public, max-age=86400, immutable

   <!-- API 响应：根据场景选择 -->
   Cache-Control: no-store <!-- 敏感数据 -->
   Cache-Control: private, max-age=60 <!-- 短期缓存 -->
   ```

2. **最佳实践**

   ```html
   <!-- 1. 资源指纹策略 -->
   <link rel="stylesheet" href="styles.css?v=1.2.3" />
   <link rel="stylesheet" href="styles.a8f3e901.css" />
   <!-- 内容哈希 -->

   <!-- 2. 版本化 URL -->
   <script src="/v2/app.js"></script>

   <!-- 3. CDN 和缓存配置 -->
   <link
     rel="stylesheet"
     href="https://cdn.example.com/styles.css"
     crossorigin
   />

   <!-- 4. 不同类型资源分域名存储 -->
   <img src="https://img.example.com/logo.png" />
   <script src="https://static.example.com/app.js"></script>
   ```

3. **缓存失效策略**

   ```javascript
   // 1. 发布新版本时清除 Service Worker 缓存
   self.addEventListener('activate', (event) => {
     const cacheWhitelist = ['v2-cache'] // 新缓存版本

     event.waitUntil(
       caches.keys().then((cacheNames) => {
         return Promise.all(
           cacheNames.map((cacheName) => {
             if (cacheWhitelist.indexOf(cacheName) === -1) {
               // 删除旧版本缓存
               return caches.delete(cacheName)
             }
           })
         )
       })
     )
   })

   // 2. 动态更新缓存
   self.addEventListener('fetch', (event) => {
     event.respondWith(
       caches.match(event.request).then((cachedResponse) => {
         // 返回缓存同时发起请求更新缓存
         const fetchPromise = fetch(event.request).then((networkResponse) => {
           // 更新缓存
           if (networkResponse && networkResponse.status === 200) {
             const responseToCache = networkResponse.clone()
             caches.open(CACHE_NAME).then((cache) => {
               cache.put(event.request, responseToCache)
             })
           }
           return networkResponse
         })
         return cachedResponse || fetchPromise
       })
     )
   })
   ```

4. **注意事项**

   - 缓存控制

     - 合理设置 Cache-Control
     - 为静态资源添加长期缓存
     - 使用版本号或内容哈希控制缓存更新

   - 验证机制

     - 使用 ETag 而非 Last-Modified 实现更精确的验证
     - 避免使用基于时间的脆弱验证

   - 性能考虑

     - 避免所有资源都不缓存
     - 关键资源考虑预加载和缓存
     - 合理使用 Service Worker 提升离线体验

   - 缓存问题排查
     - 使用开发者工具的网络面板
     - 通过 Disable cache 选项测试无缓存状态
     - 使用 `Ctrl+F5` 强制刷新绕过缓存

5. **开发者控制与浏览器自动缓存**

   - 需要开发者设置的缓存

     - HTTP 缓存（通过服务器响应头配置）
       - 强缓存：Expires, Cache-Control
       - 协商缓存：Last-Modified, ETag
     - Service Worker 缓存（需编写 JS 代码实现）
       - 注册 Service Worker
       - 定义缓存策略
       - 管理缓存更新和失效

   - 浏览器自动管理的缓存

     - Memory Cache（内存缓存）
       - 浏览器自动分配内存空间
       - 根据使用频率和资源大小自动管理
       - 标签页关闭时自动清空
     - Disk Cache（硬盘缓存）
       - 基于 HTTP 缓存头信息自动存储
       - 根据浏览器自身策略管理容量
       - 持久化存储直到过期或手动清除

   - 混合控制
     - 开发者通过 HTTP 头指导浏览器如何缓存资源
     - 浏览器决定资源存储在内存还是硬盘
     - 用户可通过浏览器设置或操作来影响缓存行为

## 07. 详细介绍一下 File API

### 简要回答

File API 是一组 JavaScript API，允许网页应用读取和操作用户选择的文件或拖放到浏览器中的文件。它主要包括 File 对象、FileList 集合、FileReader 接口、Blob 对象等，使开发者能够在客户端处理文件，而无需将文件上传到服务器。

### 详细解答

1. **File 对象与 FileList**

   ```javascript
   // 1. 从 input 元素获取文件
   const fileInput = document.querySelector('input[type="file"]')

   fileInput.addEventListener('change', (event) => {
     // 获取 FileList 对象
     const files = event.target.files

     // 获取单个 File 对象
     const file = files[0]

     // File 对象的属性
     console.log('文件名称:', file.name)
     console.log('文件类型:', file.type)
     console.log('文件大小:', file.size, '字节')
     console.log('最后修改时间:', file.lastModified)
   })
   ```

2. **Blob 对象**

   ```javascript
   // 1. 创建 Blob 对象
   const textContent = 'Hello, World!'
   const blob = new Blob([textContent], { type: 'text/plain' })

   console.log('Blob 大小:', blob.size)
   console.log('Blob 类型:', blob.type)

   // 2. 从 Blob 创建 URL
   const blobUrl = URL.createObjectURL(blob)
   console.log('Blob URL:', blobUrl)

   // 3. 创建 File 对象
   const file = new File([blob], 'hello.txt', { type: 'text/plain' })
   ```

3. **FileReader 接口**

   ```javascript
   // 1. 读取文本文件
   const reader = new FileReader()

   reader.addEventListener('load', (event) => {
     // 读取完成后的回调
     const result = event.target.result
     console.log('文件内容:', result)
   })

   reader.addEventListener('error', () => {
     console.error('文件读取错误')
   })

   // 开始读取文件（作为文本）
   reader.readAsText(file)

   // 2. 其他读取方法
   // 读取为数据 URL
   // reader.readAsDataURL(file);

   // 读取为 ArrayBuffer
   // reader.readAsArrayBuffer(file);

   // 读取为二进制字符串
   // reader.readAsBinaryString(file);
   ```

4. **拖放文件**

   ```javascript
   // 1. 拖放区域设置
   const dropZone = document.getElementById('drop-zone')

   // 阻止默认行为（非常重要）
   ;['dragenter', 'dragover', 'dragleave', 'drop'].forEach((eventName) => {
     dropZone.addEventListener(eventName, (e) => {
       e.preventDefault()
       e.stopPropagation()
     })
   })

   // 添加视觉反馈
   ;['dragenter', 'dragover'].forEach((eventName) => {
     dropZone.addEventListener(eventName, () => {
       dropZone.classList.add('highlight')
     })
   })
   ;['dragleave', 'drop'].forEach((eventName) => {
     dropZone.addEventListener(eventName, () => {
       dropZone.classList.remove('highlight')
     })
   })

   // 处理拖放的文件
   dropZone.addEventListener('drop', (e) => {
     const files = e.dataTransfer.files
     handleFiles(files)
   })

   function handleFiles(files) {
     // 处理拖放的文件
     Array.from(files).forEach((file) => {
       console.log('拖放文件:', file.name)
     })
   }
   ```

### 使用建议

1. **文件预览**

   ```javascript
   // 1. 图片预览
   function previewImage(file) {
     // 检查文件类型
     if (!file.type.match('image.*')) {
       console.error('非图片文件')
       return
     }

     const reader = new FileReader()

     reader.addEventListener('load', (event) => {
       const imgElement = document.createElement('img')
       imgElement.src = event.target.result
       document.getElementById('preview').appendChild(imgElement)
     })

     reader.readAsDataURL(file)
   }

   // 2. 视频预览
   function previewVideo(file) {
     if (!file.type.match('video.*')) {
       return
     }

     const videoURL = URL.createObjectURL(file)
     const videoElement = document.createElement('video')
     videoElement.src = videoURL
     videoElement.controls = true
     document.getElementById('preview').appendChild(videoElement)

     // 使用完毕后释放 URL
     videoElement.onload = () => {
       URL.revokeObjectURL(videoURL)
     }
   }
   ```

2. **文件上传**

   ```javascript
   // 1. 使用 XMLHttpRequest 上传
   function uploadFile(file) {
     const xhr = new XMLHttpRequest()
     const formData = new FormData()

     // 监听上传进度
     xhr.upload.addEventListener('progress', (e) => {
       if (e.lengthComputable) {
         const percentComplete = (e.loaded / e.total) * 100
         console.log('上传进度: ' + percentComplete.toFixed(2) + '%')
       }
     })

     xhr.open('POST', '/upload')

     formData.append('file', file)
     xhr.send(formData)
   }

   // 2. 使用 Fetch API 上传
   async function uploadFileWithFetch(file) {
     const formData = new FormData()
     formData.append('file', file)

     try {
       const response = await fetch('/upload', {
         method: 'POST',
         body: formData
       })

       if (response.ok) {
         const result = await response.json()
         console.log('上传成功:', result)
       } else {
         console.error('上传失败')
       }
     } catch (error) {
       console.error('上传错误:', error)
     }
   }
   ```

3. **文件切片与断点续传**

   ```javascript
   // 1. 文件切片
   function sliceFile(file, chunkSize = 1024 * 1024) {
     // 默认 1MB 切片
     const chunks = []
     let start = 0

     while (start < file.size) {
       const end = Math.min(start + chunkSize, file.size)
       const chunk = file.slice(start, end)
       chunks.push(chunk)
       start = end
     }

     return chunks
   }

   // 2. 上传切片
   async function uploadChunks(file, chunkSize) {
     const chunks = sliceFile(file, chunkSize)
     const totalChunks = chunks.length

     for (let i = 0; i < totalChunks; i++) {
       const formData = new FormData()
       formData.append('file', chunks[i])
       formData.append('fileName', file.name)
       formData.append('chunkIndex', i)
       formData.append('totalChunks', totalChunks)

       try {
         await fetch('/upload-chunk', {
           method: 'POST',
           body: formData
         })
         console.log(`已上传 ${i + 1}/${totalChunks} 个分片`)
       } catch (error) {
         console.error(`分片 ${i} 上传失败:`, error)
         // 断点续传逻辑可以在这里实现
         return i // 返回失败的索引，用于续传
       }
     }

     // 通知服务器所有分片已上传
     await fetch('/merge-chunks', {
       method: 'POST',
       headers: { 'Content-Type': 'application/json' },
       body: JSON.stringify({ fileName: file.name, totalChunks })
     })

     return -1 // 表示全部上传成功
   }
   ```

4. **注意事项**

   - 安全考虑

     - 始终在服务器端验证文件类型和大小
     - 避免仅依赖客户端验证（如 MIME 类型检查）
     - 注意用户隐私和敏感数据处理

   - 性能优化

     - 对大文件使用切片上传
     - 使用 `URL.createObjectURL()` 而非 `FileReader.readAsDataURL()` 创建预览
     - 及时调用 `URL.revokeObjectURL()` 释放内存
     - 使用 Web Workers 处理大文件以避免阻塞主线程

   - 用户体验

     - 提供上传进度反馈
     - 支持多文件拖放操作
     - 添加文件类型和大小限制提示
     - 实现缩略图预览

   - 兼容性问题
     - 检查 File API 的浏览器兼容性
     - 为旧版浏览器提供备选方案
     - 测试不同操作系统和设备的行为差异

5. **实际应用场景**

   ```html
   <!-- 1. 完整的文件上传组件 -->
   <div class="file-uploader">
     <div id="drop-zone" class="drop-zone">
       拖放文件到这里或
       <label for="file-input" class="file-label">选择文件</label>
       <input type="file" id="file-input" multiple hidden />
     </div>

     <div id="preview" class="preview-container"></div>

     <div id="upload-progress" class="progress-bar"></div>

     <button id="upload-button" disabled>开始上传</button>
   </div>

   <!-- 2. 大文件处理应用 -->
   <div class="file-processor">
     <input type="file" id="large-file-input" />
     <button id="process-button">处理文件</button>
     <div id="processing-status"></div>
   </div>
   ```

   ```css
   /* 样式示例 */
   .drop-zone {
     border: 2px dashed #ccc;
     border-radius: 4px;
     padding: 20px;
     text-align: center;
     margin-bottom: 20px;
     transition: all 0.3s;
   }

   .drop-zone.highlight {
     border-color: #2196f3;
     background-color: rgba(33, 150, 243, 0.1);
   }

   .file-label {
     color: #2196f3;
     cursor: pointer;
   }

   .preview-container {
     display: flex;
     flex-wrap: wrap;
     gap: 10px;
   }

   .preview-container img {
     max-width: 150px;
     max-height: 150px;
     object-fit: cover;
   }

   .progress-bar {
     height: 10px;
     background-color: #f0f0f0;
     border-radius: 5px;
     margin: 15px 0;
     overflow: hidden;
   }

   .progress-bar::before {
     content: '';
     display: block;
     height: 100%;
     width: 0%;
     background-color: #4caf50;
     transition: width 0.3s;
   }
   ```

## 08. 什么是跨标签页通信？有哪些方案？

### 简要回答

跨标签页通信是指在同一浏览器中的不同标签页之间传递消息或共享数据的技术。常见的跨标签页通信方案包括：LocalStorage 事件、BroadcastChannel API、SharedWorker、IndexedDB 轮询、Cookies 轮询、postMessage、WebSocket 和 Service Worker 等。

### 详细解答

1. **LocalStorage 事件**

   ```javascript
   // 1. 发送消息（标签页 A）
   window.localStorage.setItem(
     'message',
     JSON.stringify({
       type: 'notification',
       content: '新消息',
       timestamp: Date.now()
     })
   )

   // 2. 接收消息（标签页 B）
   window.addEventListener('storage', (event) => {
     if (event.key === 'message') {
       const data = JSON.parse(event.newValue)
       console.log('收到消息:', data)
     }
   })

   // 3. 注意事项
   // - localStorage 事件只在值变化时触发
   // - 在设置值的当前页面不会触发事件
   // - 适用于同源页面之间的通信
   ```

2. **BroadcastChannel API**

   ```javascript
   // 1. 创建通道（在所有需要通信的标签页中）
   const channel = new BroadcastChannel('app_channel')

   // 2. 发送消息（任意标签页）
   channel.postMessage({
     type: 'user_action',
     action: 'logout',
     timestamp: Date.now()
   })

   // 3. 接收消息（所有标签页，包括发送方）
   channel.addEventListener('message', (event) => {
     console.log('频道消息:', event.data)

     // 根据消息类型处理
     if (event.data.type === 'user_action' && event.data.action === 'logout') {
       // 执行登出操作
     }
   })

   // 4. 关闭通道
   channel.close()
   ```

3. **SharedWorker**

   ```javascript
   // 1. 创建 SharedWorker (shared-worker.js)
   // shared-worker.js 文件内容
   const connections = []

   self.addEventListener('connect', (event) => {
     const port = event.ports[0]
     connections.push(port)

     port.addEventListener('message', (event) => {
       // 收到消息后广播给所有连接
       connections.forEach((p) => {
         if (p !== port) {
           // 可选：排除发送方
           p.postMessage(event.data)
         }
       })
     })

     port.start()
   })

   // 2. 在页面中使用 SharedWorker
   const worker = new SharedWorker('shared-worker.js')

   // 3. 发送消息
   worker.port.postMessage({
     type: 'notification',
     content: '数据已更新',
     timestamp: Date.now()
   })

   // 4. 接收消息
   worker.port.addEventListener('message', (event) => {
     console.log('Worker 消息:', event.data)
   })
   worker.port.start()
   ```

4. **IndexedDB 轮询**

   ```javascript
   // 1. 打开数据库
   const request = indexedDB.open('CrossTabDB', 1)

   request.onupgradeneeded = (event) => {
     const db = event.target.result
     if (!db.objectStoreNames.contains('messages')) {
       db.createObjectStore('messages', { keyPath: 'id', autoIncrement: true })
     }
   }

   // 2. 发送消息
   function sendMessage(message) {
     const request = indexedDB.open('CrossTabDB', 1)

     request.onsuccess = (event) => {
       const db = event.target.result
       const transaction = db.transaction(['messages'], 'readwrite')
       const store = transaction.objectStore('messages')

       store.add({
         content: message,
         timestamp: Date.now()
       })
     }
   }

   // 3. 轮询接收消息
   let lastChecked = Date.now()

   function checkNewMessages() {
     const request = indexedDB.open('CrossTabDB', 1)

     request.onsuccess = (event) => {
       const db = event.target.result
       const transaction = db.transaction(['messages'], 'readonly')
       const store = transaction.objectStore('messages')

       const query = IDBKeyRange.lowerBound(lastChecked, true)
       const cursorRequest = store.openCursor(query)

       cursorRequest.onsuccess = (event) => {
         const cursor = event.target.result
         if (cursor) {
           console.log('新消息:', cursor.value)
           lastChecked = cursor.value.timestamp
           cursor.continue()
         }
       }
     }
   }

   // 4. 设置定时轮询
   setInterval(checkNewMessages, 1000)
   ```

5. **postMessage 通信**

   ```javascript
   // 1. 打开新窗口
   const popup = window.open('https://example.com/other-page.html')

   // 2. 从父页面发送消息
   popup.postMessage(
     {
       type: 'parent_message',
       content: '来自父窗口的消息'
     },
     'https://example.com'
   )

   // 3. 在子页面接收消息
   // other-page.html 中的代码
   window.addEventListener('message', (event) => {
     // 验证来源
     if (event.origin === 'https://example.com') {
       console.log('收到父窗口消息:', event.data)

       // 回复消息
       event.source.postMessage(
         {
           type: 'child_response',
           content: '已收到消息'
         },
         event.origin
       )
     }
   })

   // 4. 在子页面中访问父页面
   // 如果是由父页面打开的
   if (window.opener) {
     window.opener.postMessage(
       {
         type: 'child_message',
         content: '子窗口消息'
       },
       'https://example.com'
     )
   }
   ```

6. **WebSocket**

   ```javascript
   // 1. 创建 WebSocket 连接
   const socket = new WebSocket('wss://echo.websocket.org')

   // 2. 发送消息
   socket.addEventListener('open', () => {
     // 发送包含标签页标识的消息
     socket.send(
       JSON.stringify({
         tabId: generateUniqueId(),
         type: 'tab_message',
         content: '标签页同步消息',
         timestamp: Date.now()
       })
     )
   })

   // 3. 接收消息
   socket.addEventListener('message', (event) => {
     const data = JSON.parse(event.data)

     // 忽略自己发送的消息
     if (data.tabId !== myTabId) {
       console.log('WebSocket 收到消息:', data)
     }
   })

   // 4. 生成唯一标识
   function generateUniqueId() {
     return Date.now().toString(36) + Math.random().toString(36).substr(2)
   }
   ```

7. **Service Worker**

   ```javascript
   // 1. 注册 Service Worker
   navigator.serviceWorker.register('sw.js').then((registration) => {
     console.log('Service Worker 注册成功')
   })

   // 2. Service Worker 实现 (sw.js)
   // 保存所有活动的客户端
   const clients = []

   // 处理客户端连接
   self.addEventListener('message', (event) => {
     // 广播消息给所有其他客户端
     self.clients.matchAll().then((clientList) => {
       clientList.forEach((client) => {
         // 不发送给消息来源的客户端
         if (client.id !== event.source.id) {
           client.postMessage({
             type: 'broadcast',
             originalClientId: event.source.id,
             payload: event.data
           })
         }
       })
     })
   })

   // 3. 页面发送消息
   navigator.serviceWorker.controller.postMessage({
     type: 'user_action',
     action: 'data_updated',
     payload: {
       /* 数据 */
     }
   })

   // 4. 页面接收消息
   navigator.serviceWorker.addEventListener('message', (event) => {
     console.log('Service Worker 消息:', event.data)
   })
   ```

8. **Cookies + 轮询**

   ```javascript
   // 1. 设置 Cookie
   function sendMessage(message) {
     document.cookie = `crossTabMessage=${encodeURIComponent(
       JSON.stringify({
         content: message,
         timestamp: Date.now()
       })
     )}; path=/`
   }

   // 2. 读取 Cookie
   function getCookieMessage() {
     const match = document.cookie.match(/crossTabMessage=([^;]+)/)
     if (match) {
       try {
         return JSON.parse(decodeURIComponent(match[1]))
       } catch (e) {
         return null
       }
     }
     return null
   }

   // 3. 轮询检查
   let lastTimestamp = Date.now()

   function checkCookieMessages() {
     const message = getCookieMessage()
     if (message && message.timestamp > lastTimestamp) {
       console.log('Cookie 新消息:', message)
       lastTimestamp = message.timestamp
     }
   }

   // 4. 设置轮询
   setInterval(checkCookieMessages, 1000)
   ```

### 使用建议

1. **方案选择**

   ```javascript
   /**
    * 1. 方案对比
    *
    * LocalStorage:
    * - 优点: 简单易用，兼容性好
    * - 缺点: 仅同源，存储大小有限（5-10MB）
    *
    * BroadcastChannel:
    * - 优点: API 简洁，性能好
    * - 缺点: 兼容性较差（IE不支持）
    *
    * SharedWorker:
    * - 优点: 专为多标签通信设计，性能好
    * - 缺点: 兼容性问题，调试较复杂
    *
    * postMessage:
    * - 优点: 可跨域，安全性高
    * - 缺点: 需要有页面引用关系
    *
    * WebSocket:
    * - 优点: 跨域，实时，可扩展到不同设备
    * - 缺点: 需要服务器支持
    *
    * Service Worker:
    * - 优点: 功能强大，可离线工作
    * - 缺点: 设置复杂，兼容性问题
    */

   // 2. 根据场景选择
   function selectCrossTabbingMethod(requirements) {
     if (requirements.crossOrigin) {
       if (requirements.realtime) {
         return 'WebSocket'
       } else {
         return 'postMessage'
       }
     } else {
       if (requirements.simple) {
         return 'LocalStorage'
       } else if (requirements.modern) {
         return 'BroadcastChannel'
       } else if (requirements.complex) {
         return 'SharedWorker'
       }
     }
   }
   ```

2. **安全注意事项**

   ```javascript
   // 1. 数据验证
   function validateMessage(data) {
     // 检查数据格式
     if (!data || typeof data !== 'object') {
       return false
     }

     // 检查必要字段
     if (!data.type || !data.timestamp) {
       return false
     }

     // 检查时间戳是否合理
     const now = Date.now()
     if (data.timestamp > now || data.timestamp < now - 3600000) {
       return false // 消息不应该来自未来或一小时前
     }

     return true
   }

   // 2. 防止 XSS
   function sanitizeMessage(message) {
     // 简单的 HTML 转义示例
     const escaped = {
       ...message,
       content: message.content
         .replace(/</g, '&lt;')
         .replace(/>/g, '&gt;')
         .replace(/"/g, '&quot;')
         .replace(/'/g, '&#039;')
     }
     return escaped
   }

   // 3. 使用 postMessage 时验证源
   window.addEventListener('message', (event) => {
     // 始终验证消息来源
     if (event.origin !== 'https://trusted-site.com') {
       console.error('收到不信任来源的消息')
       return
     }

     // 处理消息
     const data = event.data
     if (validateMessage(data)) {
       processMessage(data)
     }
   })
   ```

3. **性能优化**

   ```javascript
   // 1. 节流消息发送
   function throttleSend(sendFn, delay = 100) {
     let lastSend = 0
     let queuedMessage = null
     let timeout = null

     return function (message) {
       const now = Date.now()

       // 清除之前的延迟发送
       if (timeout) {
         clearTimeout(timeout)
         timeout = null
       }

       if (now - lastSend >= delay) {
         // 可以立即发送
         lastSend = now
         sendFn(message)
       } else {
         // 排队延迟发送
         queuedMessage = message
         timeout = setTimeout(() => {
           lastSend = Date.now()
           sendFn(queuedMessage)
           queuedMessage = null
           timeout = null
         }, delay - (now - lastSend))
       }
     }
   }

   // 使用节流函数
   const throttledSendMessage = throttleSend(sendMessage)

   // 2. 批量处理消息
   let messageQueue = []

   function queueMessage(message) {
     messageQueue.push(message)

     // 如果队列中只有一个消息，安排处理
     if (messageQueue.length === 1) {
       setTimeout(processMessageQueue, 50)
     }
   }

   function processMessageQueue() {
     // 处理所有排队的消息
     const messages = [...messageQueue]
     messageQueue = []

     // 批量处理
     console.log(`批量处理 ${messages.length} 条消息`)
     messages.forEach(processMessage)
   }
   ```

4. **应用场景**

   ```javascript
   // 1. 用户登录状态同步
   function broadcastLoginStatus(isLoggedIn) {
     if (typeof BroadcastChannel !== 'undefined') {
       const authChannel = new BroadcastChannel('auth_channel')
       authChannel.postMessage({
         type: 'auth_change',
         isLoggedIn,
         timestamp: Date.now()
       })
       authChannel.close()
     } else {
       // 降级到 localStorage
       localStorage.setItem(
         'auth_status',
         JSON.stringify({
           isLoggedIn,
           timestamp: Date.now()
         })
       )
     }
   }

   // 2. 多标签表单协同
   function syncFormData(formData) {
     localStorage.setItem(
       'form_data',
       JSON.stringify({
         data: formData,
         timestamp: Date.now()
       })
     )
   }

   // 监听表单变化
   document.querySelector('form').addEventListener('input', (e) => {
     const formData = new FormData(e.currentTarget)
     const data = Object.fromEntries(formData.entries())
     syncFormData(data)
   })

   // 3. 标签页通信 UI 示例
   /*
   <div class="tab-messenger">
     <div class="tab-status">
       <span class="active-tabs">活动标签页: <span id="tabCount">1</span></span>
       <span class="tab-id">当前标签页 ID: <span id="currentTabId">tab_123</span></span>
     </div>
     <div class="message-composer">
       <input type="text" id="messageInput" placeholder="输入要发送的消息">
       <button id="sendBtn">发送给其他标签页</button>
     </div>
     <div class="message-list">
       <h3>收到的消息:</h3>
       <ul id="messages"></ul>
     </div>
   </div>
   */
   ```

5. **注意事项**

   - 兼容性问题

     - BroadcastChannel 和 SharedWorker 在旧浏览器中不可用
     - 提供降级方案（如回退到 localStorage）
     - 测试目标浏览器的支持情况

   - 安全考虑

     - 敏感数据不应通过 localStorage 传递
     - 验证接收到的所有消息
     - 跨域 postMessage 时始终验证源

   - 性能影响

     - 避免高频通信导致性能问题
     - 考虑消息节流或批处理
     - 大数据量考虑使用 IndexedDB 而非 localStorage

   - 应用状态管理
     - 考虑与应用状态管理（如 Redux）的集成
     - 标签页间通信应作为状态更新的一部分
     - 保持通信模式的一致性
